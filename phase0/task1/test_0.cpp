void fun_0(){
}

inline void fun_1(){
}

void test(){
    fun_0();
    fun_1();
}

inline int value=0;
int main(){
    // O0:上面所有函数都没有内联
    // O2:上面所有函数都有内联
    // 所以inline实际上已经失去了建议编译器优化的作用，现在更多的作用是ODR规则，即多个源文件中定义的函数不认为是重复定义，
    // 比如一个头文件定义了一个函数，如果多个源文件饮用，不inline的情况下会被认为重复定义，而inline则不会，同理对于变量也可以有同样作用
    test();
    // 写出更容易被编译器内敛的代码：将函数定义放到头文件，被调用点看到；函数小巧，无循环，无大量局部变量，避免取函数地址（需要真实符号？）；
    // 启用LTO；不要递归，尾部递归优化为循环；
    return 0;
}